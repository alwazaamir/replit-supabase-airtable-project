Build a multi-tenant SaaS starter using Next.js (App Router) + Supabase + Stripe + Airtable integration.

STACK
- Next.js (TypeScript), server actions, route handlers
- Supabase: Auth, Postgres, RLS, Storage
- Stripe: subscriptions (Free, Pro, Team), metered events
- Airtable: per-organization Base + Table config
- Replit: Deploy + Scheduled jobs (cron)

ENV
- SUPABASE_URL, SUPABASE_ANON_KEY, SUPABASE_SERVICE_ROLE
- STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET, STRIPE_PRICE_PRO, STRIPE_PRICE_TEAM
- AIRTABLE_API_KEY (optional per-org override via DB)
- POSTMARK_TOKEN or RESEND_API_KEY (or stubbed “console mailer”)
- APP_URL

AUTH & TENANCY
- Supabase Auth (email magic link/password)
- Tables:
  organizations(id uuid pk, name text, owner_id uuid, stripe_customer_id text, stripe_subscription_id text, plan text, trial_end timestamptz, created_at)
  org_members(org_id uuid fk, user_id uuid fk, role text check in ['admin','editor','viewer'], created_at, pk(org_id,user_id))
  api_keys(id uuid pk, org_id uuid fk, name text, key_hash text, last_used_at, created_at)
  settings(org_id uuid fk, key text, value jsonb, pk(org_id,key))
  subscriptions(org_id uuid fk, plan text, status text, period_end timestamptz, metered jsonb, updated_at)
  audit_logs(id bigserial pk, org_id uuid, actor_id uuid, action text, entity text, entity_id text, meta jsonb, created_at)
  job_queue(id bigserial pk, org_id uuid, type text, payload jsonb, run_at timestamptz, status text, attempts int, last_error text, created_at)

- RLS patterns (apply to all domain tables you’ll add):
  * Enable RLS; default deny.
  * SELECT: auth.uid() IN (SELECT user_id FROM org_members WHERE org_id = <table>.org_id)
  * INSERT/UPDATE/DELETE: require role IN ('admin','editor') for write; only 'admin' for destructive ops where relevant.
  * For audit_logs, allow SELECT to org members; INSERT via server actions only.

STRIPE BILLING
- Plans:
  Free: 1 org, 3 members, 1,000 monthly operations, 1 Airtable table mapping
  Pro: 5 orgs, 15 members, 100,000 monthly operations, 10 table mappings
  Team: 20 orgs, 50 members, 1M monthly operations, 30 mappings
- Checkout session routes: /api/billing/checkout, /api/billing/portal
- Webhook: /api/billing/stripe-webhook to update subscriptions table
- Middleware to read plan + limits into request context

AIRTABLE INTEGRATION
- settings keyed by:
  airtable.apiKey (optional override), airtable.baseId, airtable.tables (array of {name, mapping})
- Safe client wrapper with rate limiting + retry + ETag delta reads

DX & OPS
- Script: npm run db:types (generate Supabase types)
- Seed: create org, owner, dummy data
- Reusable server util: withOrg() to assert org context
- Metrics endpoint: /api/internal/metrics (protected)
- Cron jobs: /api/cron/* invoked via Replit schedule (document how to schedule)

UI
- App shell: Org switcher, billing banner, member management, API keys, audit log
- Org-scoped layout: set active org_id in cookie or search param; server actions validate membership

TESTS
- Unit tests for RBAC middleware, RLS via pgTAP or Zod test harness
- Webhook signature tests for Stripe
- Airtable integration mocked

Deliver production-ready code with:
- All tables + RLS SQL migrations
- Pages: /dashboard, /orgs, /members, /billing, /settings/integrations, /api-keys, /logs
- .env.example and README with setup steps